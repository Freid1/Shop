<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Git</title>
    <style>
        body {
            background-image: url("../resources/images/daketJSBack.gif");
            margin: 50px;
            font-size: 25px;

        }

        #test {
            color: yellow;
        }
    </style>
</head>
<body>
<header>
    <h1 id="js001">Git</h1>
    <h3><a href="../index.html">Главная страница</a></h3>
</header>
<nav>Содержание
    <ol>
        <li><a href="#basic">Основы Git</a></li>
        <li><a href="#branch">Ветвление в Git</a></li>
        <li><a href="#hub">GitHub</a></li>
        <li><a href="#config">Настройка Git</a></li>
        <li><a href="#misc">Разное</a></li>

    </ol>
</nav>

<section>
    <h3 id="basic">Основы Git</h3>
    <div>
        Git имеет три основных состояния:
        1. Зафиксированном (committed) -значит, что файл уже сохранён в вашей локальной базе.<br>
        2. Изменённом (modified) -относятся файлы, которые поменялись, но ещё не были зафиксированы.<br>
        3. Подготовленном (staged)-это изменённые файлы, отмеченные для включения в следующий коммит.<br><br>

        Установка на Linux ($ apt-get install git)<br><br>

        $ git init-Эта команда создаёт в текущей директории новую поддиректорию с именем .git,
        содержащую все необходимые файлы репозитория <br><br>
        $ git add *.c -добавляем в индекс все документы .c <br>
        $ git add LICENSE -добавляем файл<br>
        $ git commit -m 'initial project version' -комитем и добавляем пометку<br><br>
        git clone [url] ($ git clone https://github.com/libgit2/libgit2) +(можно добавить имя- меняющую папку libgit2 на
        своеhttps://github.com/libgit2/libgit2)
        Эта команда создаёт директорию “libgit2”, инициализирует в ней поддиректорию .git,
        скачивает все данные для этого репозитория.<br>
        git status - Основной инструмент, используемый для определения, какие файлы в каком состоянии находятся <br>
        git status -s или git status --short гораздо более упрощенный вывод<br>
        git diff -ответит на вопросы что вы изменили, но ещё не проиндексировали, и что вы проиндексировали и
        собираетесь
        фиксировать. <br>
        git difftool вместо git diff, таким образом вы сможете просмотреть изменения в файле с помощью таких программ
        как Araxis,
        emerge, vimdiff и других. ( git difftool --tool-help) <br>
        <br>
        Группа файлов, которые вы не только не хотите автоматически
        добавлять в репозиторий, но и видеть в списках неотслеживаемых, вы можете создать файл .gitignore. с
        перечислением
        шаблонов соответствующих таким файлам.
        <br>
        GitHub поддерживает довольно полный список примеров .gitignore файлов для множества проектов и языков<br>
        <a href="https://github.com/github/gitignore" target="_blank"> https://github.com/github/gitignore </a> это
        может стать
        отправной точкой для .gitignore в вашем проекте. <br>
        <br>
        git commit-Эта команда откроет выбранный вами текстовый редактор, где надо добавить коменты и после сохранения
        будет комитется файлы<br>
        $ git commit -m "Story 182: Fix benchmarks for speed"(второй способ где коменты задаются сразу (-m param))<br>
        <br>
        $ git commit -a -m 'added new benchmarks' -Добавление параметра -a в команду git commit заставляет Git
        автоматически
        индексировать каждый уже отслеживаемый на момент коммита файл, позволяя вам обойтись без git add <br>
        <br>
        git rm - удалит его из отслеживаемых файлов (точнее, удалить его из вашего индекса) а затем выполнить коммит,
        которая также удаляет файл из вашего рабочего каталога <br>
        Если вы изменили файл и уже проиндексировали его, вы должны использовать принудительное
        удаление с помощью параметра -f<br>
        git rm --cached README -то удалить файл из индекса, оставив его при этом в рабочем каталоге<br>
        В команду git rm можно передавать файлы, каталоги или glob-шаблоны.(git rm log/\*.log) <br>
        Если вам хочется переименовать файл в Git, вы можете сделать что-то вроде: $ git mv file_from file_to (git mv
        README.md README)<br>
        Однако, это эквивалентно выполнению следующих команд:<br>
        $ mv README.md README<br>
        $ git rm README.md<br>
        $ git add README<br><br>
        git log -Просмотр истории коммитов<br>
        git log -p, который показывает разницу,внесенную в каждый коммит. <br>
        Так же вы можете использовать аргумент -2, который позволяет установить лимит на вывод количества коммитов.<br>
        git log --stat Статистика измененных файлов<br>
        git log --pretty=full (short, full и fuller) Эта опция меняет формат вывода<br>
        $ git log --pretty=format:"%h - %an, %ar : %s" -она позволяет создать свой формат для вывода информации<br>
        <br>
        $ git log --since=2.weeks Опции для ограничения вывода по времени, такие как --since и --until, являются
        очень удобными. <br>
        Опции для ограничения вывода команды git log<br>
        -(n) Показывает только последние n коммитов.<br>
        --since, --after Показывает только те коммиты, которые были сделаны
        после указанной даты.<br>
        --until, --before Показывает только те коммиты, которые были сделаны до
        указанной даты.<br>
        --author
        Показывает только те коммиты, в которых запись author
        совпадает с указанной строкой.<br>
        --committer
        Показывает только те коммиты, в которых запись committer
        совпадает с указанной строкой.<br>
        --grep
        Показывает только коммиты, сообщение которых содержит
        указанную строку.<br>
        -S
        Показывает только коммиты, в которых изменение в коде
        повлекло за собой добавление или удаление указанной
        строки.<br><br>
        Операции отмены<br>
        git commit --amend<br>
        Эта команда использует для дополнения коммита вашу область подготовки (индекс). Если
        вы ничего не меняли с момента последнего коммита , то снимок состояния останется в точности таким же, а
        изменится лишь комментарий к коммиту.<br>
        $ git commit -m 'initial commit'<br>
        $ git add forgotten_file<br>
        $ git commit --amend<br>
        В итоге получится единый коммит — второй коммит заменит результаты первого.<br>
        <br>
        Отмена подготовки файла<br>
        $ git reset HEAD NameFile.md -для отмены добавления в индекс<br>
        git checkout -- [file] — опасная команда. Любые
        изменения соответствующего файла пропадают — вы просто
        копируете поверх него другой файл. Ни в коем случае не используйте
        эту команду, если вы не убеждены, что файл вам не нужен.<br>
        <br>

        Работа с удалёнными репозиториями <br>
        Просмотр удалённых репозиториев<br>
        git remote -просмотреть список настроенных удалённых репозиториев, вы можете запустить команду <br>
        ключ -v, чтобы просмотреть адреса для чтения и записи,привязанные к репозиторию:<br>
        Добавление удалённых репозиториев<br>
        git remote add [shortname] [url]<br>
        git remote add pb https://github.com/paulboone/ticgit-Теперь вместо указания полного пути вы можете использовать
        pb(git fetch pb -теперь можно использовать вместо адреса)<br>
        <br>
        Получение изменений из удалённого репозитория - Fetch и Pull<br>
        git fetch забирает данные в ваш локальный репозиторий, но не сливает их с какими-либо вашими наработками<br>
        git push origin master-Отправка изменений в удаленный репозиторий (Push)<br>
        git remote show [remote-name]-Просмотр удаленного репозитория<br>
        git remote rename pb paul- переименование удалённых репозиториев<br>
        git remote rm paul-Удаление<br>
        <br>
        Работа с метками<br>
        git tag-Просмотр меток<br>
        Создание меток Git использует два основных типа меток: легковесные и аннотированные(-a).<br>
        git tag -a v1.4 -m 'my version 1.4'<br>
        Опция -m задаёт сообщение метки, которое будет храниться вместе с меткой.<br>
        Вы можете посмотреть данные метки вместе с коммитом, который был помечен, с
        помощью команды git show v1.4<br>
        Легковесная метка — это ещё один способ отметки коммитов. В сущности, это контрольная
        сумма коммита, сохранённая в файл — больше никакой информации не хранится. Для
        создания легковесной метки не передавайте опций -a, -s и -m<br>
        $ git tag v1.4-lw<br>
        По умолчанию, команда git push не отправляет метки на удалённые серверы.(git push origin [имя метки]|git push
        origin --tags -все метки)<br>
        <br>
        Псевдонимы в Git<br>
        git config --global alias.co checkout<br>
        $ git config --global alias.br branch<br>
        $ git config --global alias.ci commit<br>
        $ git config --global alias.st status<br>
        git config --global alias.unstage 'reset HEAD --'<br>
        Это делает эквивалентными следующие две команды:<br>
        $ git unstage fileA<br>
        $ git reset HEAD -- fileA<br>
        git config --global alias.last 'log -1 HEAD'<br>
        Таким образом, можно легко просмотреть последний коммит: <br>
        <br>
        or create a new repository on the command line<br>
        git init<br>
        git add README.md<br>
        git commit -m "first commit"<br>
        git remote add origin https://github.com/Freid1/Site.git<br>
        git push -u origin master<br><br>
        <a href="#top">Назад</a>
    </div>

    <h3 id="branch">Ветвление в Git</h3>
    <div>
        git branch testing -создать новую ветку с именем “testing” <br>
        Команда git branch только создает новую ветку.<br>
        git checkout testing-Чтобы переключиться на существующую ветку, выполните команду git checkout<br>
        Важно запомнить, что когда вы переключаете ветки в Git, файлы в рабочем
        каталоге меняются. Если вы переключаетесь на старую ветку, то рабочий
        каталог будет выглядеть так же, как выглядел на момент последнего коммита
        в ту ветку.<br>
        git log --oneline --decorate --graph --all выдаст историю ваших коммитов и покажет, где находятся
        указатели ваших веток <br>
        git checkout -b newBranch -Чтобы создать ветку и сразу переключиться на нее, можно
        выполнить команду git checkout с параметром -b -<br>
        $ git checkout master<br>
        $ git merge hotfix-выполнить слияние (merge) с основной веткой для включения в продукт
        (нужно обращать внимание какая ветка куда вливается)<br>
        $git merge --no-commit --squash featureB<br>
        --squash option takes all the work on the merged branch and squashes it into one non-merge
        commit on top of the branch you’re on<br>
        <br>
        $ git branch -d hotfix-Для удаления ветки выполните команду git branch с параметром -d<br>
        Если вы действительно хотите удалить ветку и потерять наработки, вы можете сделать это при помощи опции -D
        (если есть данные которые не слиты в основную ветку -д не даст удалить а -Д разрешит) <br>
        <br>
        Иногда процесс не проходит гладко. Если вы изменили одну и ту же часть одного и того же
        файла по-разному в двух объединяемых ветках, Git не сможет их чисто объединить.<br>
        Git не создал коммит слияния автоматически. Он остановил процесс до тех пор, пока вы не
        разрешите конфликт. Чтобы в любой момент после появления конфликта увидеть, какие
        файлы не объединены, вы можете запустить git status:<br>
        Если вы хотите использовать графический инструмент для разрешения конфликтов, можно
        запустить git mergetool, что откроет соответствующее визуальное средство, которое
        проведет вас по всем конфликтам<br>
        <br>
        git branch делает несколько больше, чем просто создаёт и удаляет ветки. При
        запуске без параметров, вы получите простой список имеющихся у вас веток<br>
        git branch -v<br>
        git branch --merged-посмотреть те ветки, которые вы уже слили с текущей<br>
        git branch --no-merged - все ветки, содержащие наработки, которые вы пока ещё не слили в текущую ветку<br>
        <br>
        git fetch origin-синхронизации вашей работы с сетью(извлекает оттуда все данные, которых у вас ещё нет, и
        обновляет ваше локальное
        хранилище данных)<br>
        git push origin serverfix-Когда вы хотите поделиться веткой с окружающими, вам необходимо отправить (push) её
        на удалённый сервер, на котором у вас есть права на запись.<br>
        Если вы не хотите, чтобы ветка называлась
        serverfix на удалённом сервере, то вместо предыдущей команды выполните git push origin
        serverfix:awesomebranch. Так ваша локальная ветка serverfix отправится в ветку awesomebranch
        удалённого проекта<br>
        В следующий раз, когда один из ваших соавторов будет получать обновления с сервера, он
        получит ссылку на то, на что указывает serverfix на сервере, как удалённую ветку
        origin/serverfix<br>
        Чтобы слить эти наработки в свою текущую рабочую ветку, выполните git merge
        origin/serverfix. Если вам нужна своя собственная ветка serverfix, над которой вы сможете
        работать, то вы можете создать её на основе удалённой ветки:
        $ git checkout -b serverfix origin/serverfix<br>
        <br>
        Получение локальной ветки из удалённой ветки автоматически создаёт то, что называется
        “отслеживаемой веткой” Если, находясь на отслеживаемой ветке, вы наберёте git pull, Git уже будет знать, с
        какого сервера получить
        все удалённые ссылки и сделает слияние с соответствующей удалённой веткой.<br>
        git checkout --track origin/serverfix -настроить отслеживание и других веток<br>
        git branch -vv -посмотреть какие отслеживаемые ветки у вас установлены<br>
        Важно отметить, что эти цифры — только с каждого сервера, которые последний раз были
        извлечены. Эта команда не обращается к серверам, она говорит вам о том, что в кэше есть
        локальная информация с серверов. Если вы хотите полностью быть в курсе опережающих и
        отстающих коммитов, вам необходимо извлечь данные из всех ваших удаленных серверов
        перед запуском этой команды. Вы можете сделать нечто подобное: $ git fetch --all; git
        branch -vv<br>
        git push origin --delete serverfix-Удаление веток serverfix на удалённом сервере<br>
        <br>
        Перебазирование
        В GIT есть два способа внести изменения из одной ветки в другую: слияние (merge) и
        перебазирование (rebase)<br>
        С помощью команды rebase вы можете взять все изменения, которые были зафиксированы (commited) в
        одной ветке и применить их к другой ветке.<br>
        $ git checkout experiment<br>
        $ git rebase master - слияние веток<br>
        $ git checkout master<br>
        $ git merge experiment- выравниваем ветки<br>
        Нет абсолютно никакой
        разницы в конечном результате между двумя показанными примерами, но
        перебазирование делает историю коммитов чище. ст 90 Progit<br>
        <br>
        $ git describe master-Generating a Build Number<br>
        $ git archive master --prefix='project/' | gzip > `git describe master`.tar.gz<br>
        $ git archive master --prefix='project/' --format=zip > `git describe master`.zip<br>
        <br>
        <a href="#top">Назад</a>
    </div>
    <h3 id="hub">GitHub</h3>
    <div>
        Варианты использования гитхаба<br>
        Допиливаем чужой проект : надо зайти на чужой проект нажать FORK <br>
        $ git clone https://github.com/tonychacon/blink -Клонируем нашу копию <br>
        $ cd blink<br>
        $ git checkout -b slow-blink -Создаём тематическую ветку<br>
        Вносим свои изменения<br>
        $ git diff --word-diff -проверяем <br>
        $ git commit -a -m 'three seconds is better' -Фиксируем изменения в тематической ветку<br>
        $ git push origin slow-blink -Отправляем новую ветку в нашу копию на GitHub<br>
        Далее зайти на страницу "Branches", по адресу branches, найти интересующую ветку и открыть запрос на добавления
        изменений (Пулл-реквест). <br>
        <br>
        Advanced Pull Requests <br>
        $ git remote add upstream https://github.com/schacon/blink ① ① Add the original repository as a remote named
        “upstream”<br>
        $ git fetch upstream ② ② Fetch the newest work from that remote<br>
        $ git merge upstream/master ③ ③ Merge the main branch into your topic branch<br>
        CONFLICT (content): Merge conflict in blink.ino<br>
        $ vim blink.ino ④ ④ Fix the conflict that occured<br>
        $ git add blink.ino при слияние этот файл не был добавлен<br>
        $ git commit<br>
        $ git commit --force Принудительное<br>
        $ git push origin slow-blink ⑤ ⑤ Push back up to the same topic branch<br>
        <br>
        git log --abbrev-commit --pretty=oneline Git может вычислить уникальные сокращения SSH для ваших коммитов <br>
        <br>
        git show topic1(имя ветки) если вы хотите просмотреть последний коммит в ветке, то следующие команды
        эквивалентны<br>
        <br>
        git reflog Одна из вещей, которую Git выполняет в фоновом режиме, пока вы работаете – это ведение
        “журнала ссылок” <br>
        <br>
        git show HEAD@{5} Если вы хотите увидеть какой была HEAD вашего репозитория пять
        шагов назад,<br>
        git show master@{yesterday}<br>
        <br>
        git log -g master журнала ссылок в формате, похожем на вывод git log<br>
        <br>
        $ git show HEAD^ Еще один популярный способ указать коммит – это использовать ее родословную. Если вы
        поместите ^ в конце ссылки, Git поймет, что нужно использовать родителя этого коммита<br>
        <br>
        $ git show HEAD~3 -- HEAD~ и HEAD^ эквивалентны. Различия становятся заметными, когда вы
        указываете число. HEAD~2 означает “первый родитель первого родителя” или “прадедушка”.
        Тоже самое можно записать как HEAD^^^<br>
        <br>
        $ git log master..experiment (..)– она означает “все коммиты, которые доступны из
        ветки experiment, но не доступны из ветки master<br>
        <br>
        $ git log --left-right master...experiment (...) -Если вы хотите узнать какие коммиты есть либо в ветке master,
        либо в experiment,
        но не в обеих сразу<br>
        <br>
        <br>
        Интерактивное индексирование<br>
        $ git add -i или --interactive, Git перейдет в интерактивный
        консольный режим добавление файлов, позволяет выбрать только те файлы которые хотим +++++++++++++++++<br>
        <br>
        Индексирование по частям ст224 ProGit git add -i (добавочный 5)или git add -p или git add --patch<br>
        <br>
        Прибережение и очистка <br>
        git stash или git stash save берет измененное состояние вашей рабочей директории, то есть
        измененные отслеживаемые файлы и проиндексированные изменения, и сохраняет их в
        хранилище незавершенных изменений, которые вы можете в любое время применить
        обратно.<br>
        <br>
        git stash list посмотреть список спрятанных изменений, вы можете использовать <br>
        <br>
        $ git stash apply применить одно из предыдущих спрятанных изменений<br>
        <br>
        git stash apply --index Спрятанные изменения будут применены к вашим файлам, но файлы, которые вы ранее
        добавляли в индекс, не будут добавлены туда снова для этого надо добавить --index<br>
        <br>
        git stash drop stash@{0} - удалить stash <br>
        <br>
        git stash pop stash@{0} - чтобы применить спрятанные изменения и тут же удалить их из хранилища<br>
        <br>
        git stash -u -спрячет все неотслеживаемые файлы, которые вы создали.<br>
        <br>
        $ git stash --patch - интерактивном режим <br>
        <br>
        git stash branch test(name)Создание ветки из спрятанных изменений<br>
        <br>
        git clean -просто избавиться от изменений По умолчанию команда git clean будет удалять только неотслеживаемые
        файлы, которые
        не добавлены в список игнорируемых. <br>
        Более безопасным вариантом является использование команды git stash --all для удаления
        всего <br>
        <br>
        Для удаления всех неотслеживаемых файлов в вашей
        рабочей директории, вы можете выполнить команду git clean -f -d<br>
        <br>
        $ git clean -d -n Если вы хотите только посмотреть, что будет сделано, вы можете запустить команду с
        опцией -n, которая означает “имитируй работу команды и скажи мне, что ты будешь
        удалять”.<br>
        <br>
        git clean -x -i способ, который позволяет вам более тщательно контролировать сам
        процесс – это выполнение команды с опцией -i (в “интерактивном” режиме)<br>
        <br>
        <br>
        Подпись результатов вашей работы <br>
        Введение в GPG<br>
        gpg --list-keys <br>
        <br>
        gpg --gen-key Если у вас нет ключа, то можете сгенерировать его командой<br>
        <br>
        git config --global user.signingkey 0A46826A Если у вас есть приватный ключ для подписи, вы можете настроить Git
        так, чтобы этот
        ключ использовался для подписи<br>
        <br>
        git tag -s v1.5 -m 'my signed 1.5 tag' Подпись тегов<br>
        Если теперь для этого тега вы выполните git show, то увидите прикрепленную к нему свою
        GPG подпись:<br>
        <br>
        git commit -a -S -m 'signed commit' Подпись коммитов -S<br>
        <br>
        git log --show-signature -1 Для просмотра и проверки таких подписей у команды git log есть опция
        --show-signature<br>
        <br>
        git merge --verify-signatures non-verify В Git, начиная с версии 1.8.3, команды git merge и git pull с помощью
        опции --verify-signatures
        можно заставить проверять и отклонять слияния, если коммит не содержит
        доверенной GPG подписи. <br>
        <br>
        git merge --verify-signatures -S signed-branch Также с командой git merge вы можете использовать опцию -S, в
        этом случае полученный в
        результате слияния коммит будет подписан.<br>
        <br>
        <br>
        Поиск<br>
        Git поставляется с командой grep, которая позволяет легко искать в истории коммитов или в
        рабочем каталоге по строке или регулярному выражению.<br>
        <br>
        git grep -n print эта команда ищет по файлам в рабочем каталоге. Для отображения
        нумерации строк, в которых присутствуют совпадения(можно использовать --count выведет количество)(увидеть метод
        или функцию -p)<br>
        искать сложные комбинации строк, используя опцию --and , --break и --heading<br>
        git grep --break --heading \ -n -e '#define' --and \( -e LINK -e BUF_MAX \) v1.8.0<br>
        <br>
        Другой, довольно продвинутый, поиск по истории, который бывает черезвычайно
        полезным – поиск по истории изменений строки git log передать опцию -L<br>
        <br>
        <br>
        Исправление истории<br>
        $ git commit --amend изменить только сообщение вашего последнего коммита, не изменяйте ваш последний коммит,
        если вы
        уже отправили ее в общий репозиторий<br>
        <br>
        Изменение сообщений нескольких коммитов ст. 241<br>
        Объединение коммитов <br>
        git rebase -i С помощью интерактивного режима команды rebase также можно объединить несколько
        коммитов в один и Разбиение коммита <br>
        <br>
        <br>
        Продвинутый инструмент: filter-branch<br>
        Удаление файла из каждого коммита<br>
        git filter-branch --tree-filter 'rm -f passwords.txt' HEAD<br>
        Для выполнения filter-branch на всех ваших ветках, вы можете передать
        команде опцию --all.<br>
        <br>
        Установка поддиректории корневой директорией проекта<br>
        git filter-branch --subdirectory-filter trunk HEAD<br>
        <br>
        Глобальное изменение адреса электронной почты<br>
        <br>
        <br>
        Раскрытие тайн reset<br>
        reset – переместит то, на что указывает HEAD<br>
        git reset --soft HEAD~ -откатувается к предку рабочие данные остаются индекс старый <br>
        git reset --mixed HEAD~ -откатувается к предку рабочие данные остаются индекс отсутствует<br>
        git reset --hard HEAD~ -откатувается к предку рабочие данные стираются индекс отсутствует<br>
        git reset --mixed HEAD file.txt - откатить файл<br>
        git reset eb43bf file.txt -откатить файл комит eb43bf<br>
        <br>
        checkout перемещает сам HEAD так, чтобы он указывал на другую ветку.<br>
        <br>
        $ git checkout --conflict=diff3 hello.rb(файл с конфликтом) Использование checkout в конфликтах <br>
        <br>
        Отмена слияний<br>
        git reset --hard HEAD~<br>
        <br>
        Отмена коммита <br>
        $ git revert -m 1 HEAD лучше $ git revert ^M<br>
        <br>
        $ git read-tree --prefix=rack/ -u rack_branch(созданный через remote ссылка др. проекта)-выгрузить проект Rack в
        субдиректорию нашего основного
        проекта<br>
        $ git merge --squash -s recursive -Xsubtree=rack --no-commit rack_branch <br>
        Получаем последние измен из гита др. проекта Range и можем слить эти изменения обратно в нашу ветку master. Мы
        можем
        использовать git merge -s subtree и это будет прекрасно работать<br>
        <br>
        git blame -C -L 10,15 src/main/webapp/test.html -с помощью команды git blame снабдить файл
        аннотацией, и таким образом увидеть, когда каждая строка метода была изменена
        последний раз и кем<br>
        <br>
        Подмодули ст. 300<br>
        Подмодули позволяют вам сохранить один Git-репозиторий, как поддиректорию другого Git-репозитория.<br>
        <br>
        $ git submodule add https://github.com/chaconinc/DbConnector -добавления существующего Git-репозитория, в
        качестве подмодуля
        репозитория<br>
        new file: .gitmodules <br>
        new file: DbConnector <br>
        <br>
        $ git diff --cached --submodule Вывод информации<br>
        <br>
        Клонирование проекта с подмодулями  <br>
        Директория DbConnector присутствует, но она пустая.<br>
        Вы должны выполнить две команды:
        git submodule init – для инициализации локального конфигурационного файла, и git
        submodule update – для извлечения всех данных этого проекта и переключения на
        соответствующий коммит, указанный в вашем основном проекте<br>
        Однако, существует другой немного более простой вариант $ git clone --recursive https://github.com/chaconinc/MainProject<br>
        <br>
        $ git submodule update --remote DbConnector -Эта команда по умолчанию предполагает, что вы хотите обновить локальную копию до
        состояния ветки master из репозитория подмодуля<br>
        <br>
        Foreach для подмодулей<br>
        Затем мы можем создать новую ветку и переключиться на нее во всех наших подмодулях.<br>
        $ git submodule foreach 'git checkout -b featureA'<br>
        <br>
        Создание пакетов<br>
        $ git bundle create repo.bundle HEAD master(файл repo.bundle)<br>
        $ git clone repo.bundle repo <br>
        $ git bundle create commits.bundle master ^9a466c5 -передача обратно пакета с диапазоном от полученного(^9a466c5)до мастера<br>
        <br>
        При получении пакета коллега перед импортом его в свой репозиторий может проверить
        пакет $ git bundle verify ../commits.bundle<br>
        $ git bundle list-heads ../commits.bundle-просмотр пакета<br>
        <br>
        Замена<br>
        Команда replace позволяет вам указать объект Git и сказать "каждый раз, когда встречается
        этот объект, заменяй его другим". <br>
        Усть репо с 5 комитами<br>
        $ git branch history c6e1e95 -создаем ветку на 4 комите<br>
        $ git remote add project-history https://github.com/schacon/project-history -создаем новый репо<br>
        $ git push project-history history:master -отсылаем ветку хистори в мастер в новом репо<br>
        Для объединения этих веток вы можете просто вызывать git replace<br>
        $ git replace 81a708d c6e1e95  <br>
        <br>
        Хранилище учетных данных<br>
        <br>
        <a href="#top">Назад</a>
    </div>
    <h3 id="config">Настройка Git</h3>
    <div>
        Git’а входит утилита git config, которая позволяет просматривать и настраивать параметры:<br>
        1.Файл git/etc/gitconfig содержит значения, общие для всех пользователей системы и для
        всех их репозиториев. Если при запуске git config указать параметр --system, то
        параметры будут читаться и сохраняться именно в этот файл.<br>
        2. Файл (каталоге $HOME)~/.gitconfig или ~/.config/git/config хранит настройки конкретного пользователя.
        Этот файл используется при указании параметра --global.<br>
        3. Файл config в каталоге Git’а (т.е. .git/config) в том репозитории, который вы используете
        в данный момент, хранит настройки конкретного репозитория(--local).<br>
        Настройки на каждом следующем уровне подменяют настройки из предыдущих уровней.<br>
        <br>
        $ git config --global user.name "John Doe"<br>
        $ git config --global user.email johndoe@example.com<br>
        <br>
        git config --global core.editor "'c:/program files/Notepad++/notepad++.exe' -multiInst -notabbar -nosession
        -noPlugin"
        <br>
        <br>
        Если для каких-то отдельных проектов вы хотите указать другое имя или
        электронную почту, можно выполнить эту же команду без параметра --global в каталоге с
        нужным проектом.<br>
        git config --list, чтобы показать все настройки <br>
        git config 'key': проверить значение конкретного ключа <br>
        git help config (git config --help)помощь при использовании Git<br>
        External Merge and Diff Tools ст.343        <br>
        git config --global core.autocrlf false<br>
        Exporting Your Repository<br>

        <a href="#top">Назад</a>
    </div>
    <h3 id="misc">Разное</h3>
    <div>
        Если вы не хотите каждый раз вводить ваши данные, когда вы отправляете
        изменения, вы можете установить “кэш учетных данных”. Проще всего
        просто держать их в памяти несколько минут, вы можете легко настроить с
        помощью команды git config --global credential.helper cache.<br>
        <br>
        Команда git fetch загрузит с сервера все изменения, которых у вас еще нет, но пока не будет
        изменять вашу рабочую директорию. Эта команда просто получает данные для вас и
        позволяет вам самостоятельно сделать слияние. Тем не менее, существует команда под
        названием git pull, которая является по существу командой git fetch, непосредственно за
        которой следует команда git merge, в большинстве случаев.<br>
        <br>
        $ git config --global rerere.enabled true-(повторно использовать записанное разрешение)-используется в больших
        проектах кагда часто
        ветки сливаются или перебазируются<br>
        <br>
        git diff --word-diff -просмотр изменений<br>
        <br>
        https://username:password@github.com/USERNAME/OTHERREPOSITORY.git<br>
        <br>
        Если вы видите, что множество конфликтов слияния вызваны
        пробельными символами, то вы можете прервать слияние и запустить его снова, но на этот
        раз с опцией -Xignore-all-space или -Xignore-space-change <br>
        <br>
        Если вам нравится такой формат вывода, то вы можете использовать его по умолчанию для
        будущих конфликтов слияния, установив параметру merge.conflictstyle значение diff3.<br>
        $ git config --global merge.conflictstyle diff3<br>
        <br>
        Функциональность git rerere – частично скрытый компонент Git. Ее имя является
        сокращением для “reuse recorded resolution” (“повторное использование сохраненных
        разрешений конфликтов”). Как следует из имени, эта функциональность позволяет
        попросить Git запомнить то, как вы разрешили некоторую часть конфликта, так что в
        случае возникновения такого же конфликта, Git сможет его разрешить автоматически.<br>
        $ git config --global rerere.enabled true<br>
        <br>
        Проще всего вызвать Gitk из командной строки: Просто перейдите в директорию с
        репозиторием и наберите:
        $ gitk --all<br>
        $ git gui, в отличие от gitk — это инструмент редактирования отдельных коммитов.<br>
        <br>
        GitHub для Windows можно скачать на https://windows.github.com<br>
        <br>
        Если вы хотите использовать Git из Java-программ, существует библиотека для работы с Git,
        называемая JGit.<br>
        <br>
        <a href="#top">Назад</a>
    </div>
</section>
</body>
</html>